# github_utils.py
import os
import subprocess
import tempfile
import shutil
from pathlib import Path
from github import Github, GithubException
import requests

GITHUB_API = "https://api.github.com"


def mit_license_text():
    return """MIT License

Copyright (c) 2025

Permission is hereby granted, free of charge, to any person obtaining a copy...
"""


def create_or_upsert_github_repo_and_push(project_dir: Path, repo_name: str, token: str, owner_or_org: str = None):
    """
    Create the repo if it doesn't exist, otherwise update existing repo.
    Returns (repo_url, commit_sha, pages_url)
    """
    g = Github(token)
    repo = None

    # Attempt to get existing repo
    try:
        if owner_or_org:
            org = g.get_organization(owner_or_org)
            repo = org.get_repo(repo_name)
        else:
            user = g.get_user()
            repo = user.get_repo(repo_name)
    except GithubException:
        # Repo not found, create it
        try:
            if owner_or_org:
                repo = org.create_repo(name=repo_name, private=False, auto_init=False)
            else:
                repo = g.get_user().create_repo(name=repo_name, private=False, auto_init=False)
        except GithubException as e:
            raise RuntimeError(f"Failed to create repo: {e.data}")

    repo_url = repo.html_url
    clone_url = repo.clone_url.replace("https://", f"https://{token}@")  # for push via token

    # Prepare temporary folder for git operations
    tmp = Path(tempfile.mkdtemp())
    try:
        # Clean folder (for existing repo update)
        if tmp.exists():
            shutil.rmtree(tmp)
        tmp.mkdir(parents=True, exist_ok=True)

        # If repo exists, clone it; else, copy project files
        if repo_exists(repo, token):
            subprocess.check_call(["git", "clone", clone_url, str(tmp)])
            # Remove old files except .git
            for item in tmp.iterdir():
                if item.name == ".git":
                    continue
                if item.is_dir():
                    shutil.rmtree(item)
                else:
                    item.unlink(missing_ok=True)
        # Copy project_dir contents into tmp
        for item in project_dir.iterdir():
            dest = tmp / item.name
            if item.is_dir():
                shutil.copytree(item, dest)
            else:
                shutil.copy2(item, dest)

        # Ensure .gitignore
        (tmp / ".gitignore").write_text(".env\n*.pem\n*.key\nsecrets_map.json\n")
        # Ensure LICENSE
        if not (tmp / "LICENSE").exists():
            (tmp / "LICENSE").write_text(mit_license_text())

        # Git commit & push
        if not (tmp / ".git").exists():
            subprocess.check_call(["git", "init"], cwd=str(tmp))
            subprocess.check_call(["git", "branch", "-M", "main"], cwd=str(tmp))
            subprocess.check_call(["git", "remote", "add", "origin", clone_url], cwd=str(tmp))

        subprocess.check_call(["git", "add", "."], cwd=str(tmp))
        subprocess.check_call(["git", "commit", "-m", "Automated commit: generated by LLM generator"], cwd=str(tmp))
        subprocess.check_call(["git", "push", "-u", "origin", "main"], cwd=str(tmp))

        # Get latest commit sha
        commit_sha = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=str(tmp)).decode().strip()
        pages_url = f"https://{repo.owner.login}.github.io/{repo.name}/"

        return repo_url, commit_sha, pages_url
    finally:
        shutil.rmtree(str(tmp), ignore_errors=True)


def repo_exists(repo, token: str) -> bool:
    """
    Simple check to see if repo exists on GitHub
    """
    try:
        _ = repo.full_name
        return True
    except Exception:
        return False


def enable_github_pages(repo_url: str, token: str):
    """
    Enable GitHub Pages for a repo (main branch / root)
    """
    path = repo_url.replace("https://github.com/", "")
    api_url = f"{GITHUB_API}/repos/{path}/pages"
    headers = {"Authorization": f"token {token}", "Accept": "application/vnd.github.v3+json"}
    body = {"source": {"branch": "main", "path": "/"}}

    r = requests.post(api_url, headers=headers, json=body)
    return r.status_code in (201, 204)
